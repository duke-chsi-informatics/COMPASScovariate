---
title: "COVID"
output: html_document
date: "2023-05-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(COMPASS)
library(doParallel)
library(corrplot)
library(kableExtra)
library(PCAtools)
library(caret)
library(RColorBrewer)
library(circlize)
library(pROC)
library(ggsci)
library(Rcpp)

source("~/CHSI/PackageDev/COMPASScovariate/R/COMPASS-covariate.R")
source("~/CHSI/PackageDev/COMPASScovariate/R/updatebeta.R")
source("~/CHSI/PackageDev/COMPASScovariate/R/Scores.R")
source("~/CHSI/PackageDev/COMPASScovariate/R/utils.R")
source("~/CHSI/PackageDev/COMPASScovariate/incubator/Frances/helperscripts.R")

parentDirectory <- "~/CHSI/PackageDev/COMPASScovariate/incubator/Frances/COVID/"
```

## COVID Read-in

We get the counts matrices from COMPASS objects saved here: https://github.com/seshadrilab/Correlates_Severe_COVID19_ICS/tree/master/out/CompassOutput/4%2B/NCAP

The antibody data is here: https://github.com/seshadrilab/Correlates_Severe_COVID19_Surface_Markers/tree/master/processed_data

From the paper:

"To ensure the detection of polyfunctional T cell subsets that may be present at low frequencies, we employed Combinatorial Polyfunctionality Analysis of Antigen-Specific T Cell Subsets (COMPASS) (38). Among 128 possible functional profiles, we detected 21 antigen-specific CD4+ T cell subsets across all 4 peptide pool stimulations (Figure 3A). Notably, the probability of detecting a particular response varied according to the antigen. For example, several profiles containing 3 or 4 functions were readily detected after stimulation with S1, S2, or N but not E. However, the 2 profiles containing 5 functions (IFN-γ, IL-14/5/13, TNF, IL-2, and CD40L) were only detected after stimulation with S1. Stimulation with E resulted in a CD107a monofunctional profile that was also observed after stimulation with S2 (Figure 3A)."

- Functional diversity of CD4+ T cell responses to SARS-CoV-2 are associated with hospitalization.

On antibodies: "Archived serum was used to compare neutralizing antibody titers, as well as Ig levels, Fc receptor (FcR) binding, and Fc effector functions targeting full spike (S), S1, S2, receptor binding domain (RBD), and nucleocapsid (N) proteins...Antibody functional profiles are associated with hospitalization after COVID-19. To follow up these differences in Ig subclass, we examined several Fc-binding specificities and Fc-dependent effector functions. Fc-receptors (FcRs) specificities FcR2A, FcR2B, FcR3A, and FcR3B binding S, S1, S2, RBD, and N were significantly higher among hospitalized subjects (Supplemental Figure 2B). Antibody-dependent cellular phagocytosis (ADCP), antibody-dependent neutrophil phagocytosis (ADNP), and antibody-dependent complement deposition (ADCP) against S, RBD, and N was significantly increased among hospitalized subjects (Figure 2A). Notably, while MIP-1β secretion by NK cells was increased among hospitalized subjects, NK cell degranulation measured by CD107a expression was elevated among nonhospitalized subjects (Figure 2B). To obtain a qualitative summary of the differences in antigen-specific humoral responses between groups, we visualized Ig subclass, Fc-binding specificity, and Fc-effector functions targeting S, RBD, and N using nightingale rose graphs (Figure 2C). The results show consistently higher levels of measured analytes among hospitalized subjects, with the exception of CD107a expression on NK cells. We next examined the correlation of antibody profiles independently in hospitalized and nonhospitalized subjects. The correlation with neutralization titers in both groups was low, supporting our analysis of nonredundant aspects of the SARS-CoV-2–specific antibody response. This was surprising, given previous findings that IgG antibodies to RBD are correlated with neutralization titers (34, 35). Relative to nonhospitalized subjects, hospitalized subjects demonstrated lower correlation among antibody titers, Fc-specificities, and Fc-effector functions (Figure 2D). This difference was robust to subsampling in order to account for the unequal sample sizes in each group (Supplemental Figure 3). Finally, we calculated a polyfunctionality score for each individual for S, RBD, and N over the 6 antibody functionality readouts against 3 SARS-CoV-2 antigens. Subjects with comorbidities were able to activate a robust polyfunctional antibody response against S, RBD, and N in comparison with subjects without comorbidities (Figure 2E)." 

We don't have antibody data access, unfortunately, so let's turn to more flow parameters:

"In our matched cross-sectional analysis, we noted that the frequency of CD3+, CD4+, and CD8+ T cells did not vary significantly over time since symptom onset or between hospitalized and nonhospitalized subjects (Figure 1, D–F, and Supplemental Figures 1C). We also found no difference in the frequency of γδ T cells, iNKT cells, or MAIT cells or in B cells, monocytes, or NK cells (Figure 1G and Supplemental Figure 5, A and B). However, the frequency of activated CD8+ T cells was significantly higher among hospitalized subjects, which is consistent with prior reports (Figure 1F) (19, 36, 37). The frequency of naive CD8+ T cells was also lower among hospitalized subjects, suggesting increased differentiation to an effector phenotype in severe COVID-19; however, no difference in the frequency of naive CD4+ T cells was observed between groups (Figure 1H). Among total γδ T cells, the frequency of activated γδ T cells was higher among hospitalized subjects independent of expression of the Vδ2 gene segment (Figure 1I)."

There are 20 hospitalized patients and 40 non-hospitalized (3 are healthy controls from pre-COVID times). "For the ICS panel, data from 20 convalescent hospitalized and 37 convalescent nonhospitalized subjects were ultimately analyzed. For the surface marker panel, data from 15 convalescent hospitalized and 36 convalescent nonhospitalized subjects were analyzed."

As a covariate(s) we can consider using the antibodies included in the


### Extract Count Matrices, Antibody data, and Metadata

We first get the stimulated and unstimulated count matrices, antibody data, and metadata for the 60 patients in question. There are 20 hospitalized, 37 non-hospitalized, and 3 healthy control patients.

There are 23 CD4+ gates and 12 CD8+ gates included in the COMPASS analysis.



```{r read-in, options}

CD4 <- readRDS(file.path(parentDirectory,"0-Data/Raw/COMPASSResult_4+_NCAP.rds"))

CD4ns <- CD4$data$n_s
CD4nu <- CD4$data$n_u

CD4$data$meta %>%
  drop_na() %>%
  count(Cohort)

CD8 <- readRDS(file.path(parentDirectory,"0-Data/Raw/COMPASSResult_8+_NCAP.rds"))

CD8ns <- CD8$data$n_s
CD8nu <- CD8$data$n_u

```


There are fewer patients in the flow surface dataset than the flow ICS dataset (51, which matches with what the paper says). However, a couple of those additionally don't appear in the flow dataset, leaving us with a set of 49 common samples for CD4 and 48 common samples for CD8.

The paper found that HLADR/CD38 CD8, naive CD8, HLADR/CD38 GD, HLADR?CD38 GD/VD2+ proportions were associated with hospitalization. For COMPASS-covariate, we get rid of flow surface variables which have correlation more than 0.8. We then test three sets of covariates derived as follows:

1. Log the covariates and keep all of them.
2. Log the covariates and use PCA to keep the first 10 components
3. Don't log the covariates and keep all of them.

### Check Correlation of Surface Markers

The large correlations with absolute value more than 0.8 include:

- Monocytes_Lymphocytes_ratio vs. Monocytes_pct_Live
- CD8_pct_T vs. CD4_pct_T
- HLADR_CD38_pct_CD4 vs. HLADR_CD38_pct_CD8
- HLADR_CD38_pct_CD8 vs. HLADR_CD38_pct_GD_Vd2Neg

In addition to the CD4_CD8_ratio, GD_pct_T, HLADR_CD38_pct_GD (the redundant covariates), we get rid of Monocytes_pct_Live, CD4_pct_T, HLADR_CD38_pct_CD4, HLADR_CD38_pct_GD_Vd2Neg.

```{r corr-surface, options}
#--------------------------------------------------------
# Checking correlation
#--------------------------------------------------------

surfaceDF <- read.csv(file.path(parentDirectory, "0-Data/Raw/antibodiesCOVID.csv"))  

surfaceDF %>% select(-SAMPLE_ID) %>% as.matrix() %>% cor() %>%
  corrplot(method = 'number',
           tl.cex = 0.5,
           number.cex=0.5)

rm(surfaceDF)
```


### Split Train-Test Covariate Matrices for Transformation

In this section, we will use folds created using the caret package to divide the covariate matrices into train-test and transform training only. The scaleCenterTest and PCATest functions will be used to transform the test covariates according to the train covariates.

```{r todo, options}
surfaceDF <- read.csv(file.path(parentDirectory, "0-Data/Raw/antibodiesCOVID.csv")) %>%
  #redundant columns
  select(-c(CD4_CD8_ratio, GD_pct_T, HLADR_CD38_pct_GD,
            Monocytes_pct_Live, CD4_pct_T, HLADR_CD38_pct_CD4, HLADR_CD38_pct_GD_Vd2Neg)) %>%
  arrange(SAMPLE_ID)

# patients who have both antibody and counts info
CD4finalPats <- intersect(CD4$data$meta %>% drop_na() %>% .$`SAMPLE ID`,
                          surfaceDF$SAMPLE_ID)

CD4surfaceDF <- surfaceDF %>% filter(SAMPLE_ID %in% CD4finalPats)

CD4Parts <- createDataPartition(CD4$data$meta %>% filter(`SAMPLE ID` %in% CD4finalPats) %>% .$Cohort, p=0.8, times=5)

#--------------------------------------------------------
# Train surface marker matrices (unlogged and logged)
#--------------------------------------------------------

CD4surfaceDFs.train <- lapply(CD4Parts, function(x) CD4surfaceDF[x,] %>% 
                                `rownames<-`(c(.$SAMPLE_ID)) %>%
                                select(-SAMPLE_ID))
CD4surfaceDFs.unlog <- lapply(CD4surfaceDFs.train, function(x) x %>% 
  mutate(across(everything(), ~scale(.x))))
CD4surfaceDFs.log <- lapply(CD4surfaceDFs.train, function(x) x %>% 
  mutate(across(everything(), ~scale(log(.x + 1)))))

#--------------------------------------------------------
# Test surface markers
#--------------------------------------------------------
CD4surfaceDFs.test <- lapply(CD4Parts, function(x) CD4surfaceDF[-x,] %>% 
                                `rownames<-`(c(.$SAMPLE_ID)) %>%
                                select(-SAMPLE_ID))
CD4surfaceDFs.test.unlog <- lapply(1:5, function(i)
  scaleCenterTest(CD4surfaceDFs.train[[i]], CD4surfaceDFs.test[[i]]))
CD4surfaceDFs.test.log <- lapply(1:5, function(i)
  scaleCenterTest(CD4surfaceDFs.train[[i]] %>% mutate(across(everything(), ~log(.x+1))), 
                  CD4surfaceDFs.test[[i]] %>% mutate(across(everything(), ~log(.x+1)))))

```



Checking the surface distributions:

```{r surface-dist, options}
CD4surfaceDFs.test.unlog[[1]] %>%
  rownames_to_column(var="SAMPLE_ID") %>%
  pivot_longer(-SAMPLE_ID, names_to = "VarName", values_to="Value") %>%
  ggplot(aes(x=Value)) + geom_histogram() +
  facet_wrap(.~VarName, scales = "free")
```

And the transformed antibody distributions:

```{r trans-surface, options}
CD4surfaceDFs.test.log[[1]] %>%
  rownames_to_column(var="SAMPLE_ID") %>%
  pivot_longer(-SAMPLE_ID, names_to = "VarName", values_to="Value") %>%
  ggplot(aes(x=Value)) + geom_histogram() +
  facet_wrap(.~VarName, scales = "free")
```

### PCA

For PCA we first log and scale/center the train and test sets separately (unlike above, where we scale/center based on the train mean and SD). We then get loadings from the training data and apply those loadings to the test data to get transformed PCs.

```{r pca-logged, options}
CD4surfaceDFs.test.log.forPCA <- lapply(CD4surfaceDFs.test, function(x) x %>% 
  mutate(across(everything(), ~scale(log(.x + 1)))))

#--------------------------------------------------------
# Train and test PCA-transformed surface markers 
# PCAtools package has misleading name: the rotated matrix is really loading
#--------------------------------------------------------

CD4surfaceDFs.pca <- lapply(CD4surfaceDFs.log, function(x) {
  p <- prcomp(x, center=FALSE) 
  p$x %>% as.data.frame() %>%
    select(PC1:PC10) 
  })

# we take the rotated matrix (markers x PCs) and multiply by the test markers (obs x markers)
CD4surfaceDFs.test.pca <- lapply(1:5,
                                 function(i) PCATest(CD4surfaceDFs.log[[i]],
                                                     CD4surfaceDFs.test.log.forPCA[[i]]))

p <- pca(CD4surfaceDFs.log[[1]])
screeplot(p)
biplot(p, showLoadings = TRUE, showLoadingsNames = TRUE,
    labSize = 5, pointSize = 5, sizeLoadingsNames = 5)

#--------------------------------------------------------
# Logged, scaled, then PCA'd surface data (first 10 components)
#--------------------------------------------------------

# PCA_df_logged <- p$loadings %>% as.data.frame() %>%
#   select(PC1:PC10) %>%
#   # add Sample IDs
#   mutate(SAMPLE_ID=surfaceDF$SAMPLE_ID)
```

# Running COMPASS with the 49 Patients

We run COMPASS on the 49 patients. First, the count matrices and metadata are subsetted to include only the 49 patients of interest.

```{r compass-funcs, options}

#------------------------------------------------------
# FUNCTION for getting categories matrix for flow counts
# @params: flow DF
# @output: category matrix
#------------------------------------------------------
getCats <- function(stim) {
  # finding marker names and making category count matrix
marker_names <- unique(
    unlist( strsplit( gsub("!", "", colnames(stim)), "&", fixed=TRUE ) )
  )
  n_markers <- length(marker_names)

  cats <- as.data.frame( matrix(0, nrow=ncol(stim), ncol=length(marker_names)))
  rownames(cats) <- colnames(stim)
  colnames(cats) = marker_names

  for (i in seq_along(cats)) {
    #cats[, i] <- as.integer(grepl( paste0( colnames(cats)[i], "+" ), rownames(cats), fixed=TRUE ))
    cats[,i] <-
      as.integer(!grepl(paste0("!",colnames(cats)[i],"(&|$)+"),rownames(cats),fixed =
                          FALSE))
  }
  cats$Counts <- apply(cats, 1, sum)
  
  cats <- as.matrix(cats)
}

#-------------------------------------------------------------------------
# FUNCTION for COMPASS 
# takes in flow data frame, metadata, iterations, suffix for naming rds file, train index (from meta)
# TODO: fix to use COMPASS discrete? can we omit test_index by using PTID to get it later?
#-------------------------------------------------------------------------
COMPASS_orig <- function(n_s, n_u, individual_id, meta, iter, seed, outdir, dataName) {
  
  # n_s (I x K), n_u (I x K), iters, replications, X (I x J)
  starttime = Sys.time()
  COMPASSobj <- SimpleCOMPASS(n_s = n_s,
                                   n_u = n_u,
                                   meta=meta,
                                   individual_id = individual_id,
                                   iterations = iter,
                                   replications = 7)
  endtime= Sys.time()

saveRDS(list(COMPASSobj = COMPASSobj, runTime = endtime-starttime),
           paste0(outdir, "/", dataName, iter, "_seed", seed,".rds"))

  
rm(COMPASSobj)

}


#-------------------------------------------------------------------------
# FUNCTION for COMPASS covariate
# takes in flow data frame, covariate data frame, iterations, suffix for naming rds file, train index, seed
#-------------------------------------------------------------------------
COMPASS_covar <- function(n_s, n_u, X, categories, iter, seed, outdir, dataName) {

  # n_s (I x K), n_u (I x K), iters, replications, X (I x J)
  starttime = Sys.time()
  COMPASScovarobj <- .COMPASS.covariate(n_s=n_s, n_u=n_u,
                                         categories = categories,
                                         iterations = iter, replications = 7, X = X)
  endtime= Sys.time()

saveRDS(list(COMPASScovarobj = COMPASScovarobj, runTime = endtime-starttime),
          paste0(outdir, "/", dataName, iter, "_seed", seed,".rds"))

rm(COMPASScovarobj)

}


#########################################################
# FUNCTION for running COMPASS and COMPASS-covar for one seed
# @param
#########################################################
runCOMPASS<- function(n_s, n_u, individual_id, meta, X, categories, iter, seed, outdirorig, outdircovar, dataName) {
  COMPASS_orig(n_s, n_u, individual_id, meta, iter, seed, outdirorig, dataName)
  COMPASS_covar(n_s, n_u, X, categories, iter, seed, outdircovar, paste0(dataName, "covar"))
}
```



```{r COMPASS-prep, options}
#--------------------------------------------------------
# ns, nu, and meta are ordered the same
#--------------------------------------------------------

CD4ns_final <- CD4ns[rownames(CD4ns) %in% CD4finalPats,]
CD4nu_final <- CD4nu[rownames(CD4nu) %in% CD4finalPats,]
# all(rownames(CD4ns_final)==rownames(CD4nu_final))

CD4meta <- CD4$data$meta[CD4$data$meta$`SAMPLE ID` %in% CD4finalPats,]
# all(rownames(CD4ns_final)==CD4meta$`SAMPLE ID`)

CD4surfaceMat <- surfaceDF[surfaceDF$SAMPLE_ID %in% CD4finalPats,] %>%
  `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
  .[rownames(CD4ns_final),]
# all(rownames(CD4ns_final)==rownames(CD4surfaceMat))

CD4surfaceMat_log <- surfaceDF_logged[surfaceDF_logged$SAMPLE_ID %in% CD4finalPats,] %>%
  `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
  .[rownames(CD4ns_final),]

CD4surfaceMat_PCA <- PCA_df_logged[PCA_df_logged$SAMPLE_ID %in% CD4finalPats,] %>%
  `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
  .[rownames(CD4ns_final),]

#--------------------------------------------------------
# CD8 inputs
#--------------------------------------------------------

CD8ns_final <- CD8ns[rownames(CD8ns) %in% CD8finalPats,]
CD8nu_final <- CD8nu[rownames(CD8nu) %in% CD8finalPats,]

CD8meta <- CD8$data$meta[CD8$data$meta$`SAMPLE ID` %in% CD8finalPats,]

CD8surfaceMat <- surfaceDF[surfaceDF$SAMPLE_ID %in% CD8finalPats,] %>%
  `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
  .[rownames(CD8ns_final),]

CD8surfaceMat_log <- surfaceDF_logged[surfaceDF_logged$SAMPLE_ID %in% CD8finalPats,] %>%
  `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
  .[rownames(CD8ns_final),]

CD8surfaceMat_PCA <- PCA_df_logged[PCA_df_logged$SAMPLE_ID %in% CD8finalPats,] %>%
  `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
  .[rownames(CD8ns_final),]
```

### Dividing into Test-Train

We make a list of parameter combinations to test:

- folds (CD4-fold-1 (x3), CD8-fold-1 (x3), ..., CD4-fold-5 (x3), CD8-fold-5 (x3))
- seeds (1 (x6), 47 (x6), 100 (x6), 99 (x6), 3 (x6)))
- cov matrices (CD4 unlog, CD4 log, CD4 PCA, CD8 unlog, CD8 log, CD8 PCA) x5
- NS
- NU
- categories: (CD4 (x3), CD8 (x3)) x5

```{r test-train, options}
set.seed(47)
foldsCD4 <- createFolds(CD4meta$`SAMPLE ID`, k=5, list=TRUE, returnTrain = TRUE)
foldsCD8 <- createFolds(CD8meta$`SAMPLE ID`, k=5, list=TRUE, returnTrain = TRUE)


foldedNs <- function(foldNum, reps) {
  c(rep(list(CD4ns_final[foldsCD4[[foldNum]],]),reps),
        rep(list(CD8ns_final[foldsCD8[[foldNum]],]), reps))
}

foldedNu <- function(foldNum, reps) {
  c(rep(list(CD4nu_final[foldsCD4[[foldNum]],]),reps),
       rep(list(CD8nu_final[foldsCD8[[foldNum]],]),reps))
}

foldedMeta <- function(foldNum, reps) {
  c(rep(list(CD4meta[foldsCD4[[foldNum]],]),reps),
       rep(list(CD8meta[foldsCD8[[foldNum]],]),reps))
}

# categories
CAT <- rep(c(rep(list(getCats(CD4ns_final)), 3),
    rep(list(getCats(CD8ns_final)),3)),5)

# Ns and Nu for each simulation
NS <- c(foldedNs(1, 3), foldedNs(2, 3), foldedNs(3, 3), foldedNs(4,3 ), foldedNs(5,3))
NU <- c(foldedNu(1,3), foldedNu(2,3), foldedNu(3,3), foldedNu(4,3), foldedNu(5,3))

# seeds for each simulation
seeds <- c(rep(1,6), rep(47,6), rep(100,6), rep(99,6), rep(3,6))

# covariate matrix for each simulation
covMatrices <- rep(list(CD4surfaceMat, CD4surfaceMat_log, CD4surfaceMat_PCA,
                    CD8surfaceMat, CD8surfaceMat_log, CD8surfaceMat_PCA),5)

# save paths for each simulation
covpaths <- rep(c("all_vars/unlog/CD4", "all_vars/log/CD4", "pca/log/CD4",
              "all_vars/unlog/CD8", "all_vars/log/CD8", "pca/log/CD8"),5)
```

We run 6 covariate matrix + T-cell type combinations, crossed with 5 folds for a total of 30 runs of COMPASS-covariate.

```{r compass-covariate-run, options}



# cl <- makeCluster(30) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:30, .packages = c("dplyr", "COMPASS")) %dopar% {
#   # runCOMPASS(CD4ns_final, CD4nu_final, "SAMPLE ID",
#   #            CD4meta, covMatrices[j], getCats(CD4ns_final),
#   #            iter=2000, seed=seeds[i], "/work/fwh6/COVID/out/2000/orig",
#   #            "/work/fwh6/COVID/out/2000/covar", "CD4_COMPASStest_test")
# 
# 
#   COMPASS_covar(NS[[i]],
#                 NU[[i]], covMatrices[[i]] %>% as.data.frame() %>%
#                   filter(rownames(.) %in% rownames(NS[[i]])) %>%
#                   as.matrix(),
#                 CAT[[i]],
#                 iter=20000, seed=seeds[i],
#                 paste0("/work/fwh6/COVID/out/200000/covar/",covpaths[i]),
#                 "covar")
# }
# 
# stopCluster(cl) # stop the cluster

```


We also run COMPASS with the 5 CD4 training sets and 5 CD8 training sets. We create a new set of simulation parameters for:

- NS (folds taken from previous): CD4-fold-1, CD8-fold-1, CD4-fold-2, etc.
- NU (folds taken from previous): CD4-fold-1, CD8-fold-1, CD4-fold-2, etc
- meta (folds taken from previous): CD4-fold-1, CD8-fold-1, CD4-fold-2, etc
- seeds
- output directory (orig/CD4 or orig/CD8)

```{r compass-orig-setup, options}
NS.orig <- c(foldedNs(1, 1), foldedNs(2, 1), foldedNs(3, 1), foldedNs(4,1), foldedNs(5,1))
NU.orig <- c(foldedNu(1,1), foldedNu(2,1), foldedNu(3,1), foldedNu(4,1), foldedNu(5,1))
meta.orig <-c(foldedMeta(1,1), foldedMeta(2,1), foldedMeta(3,1), foldedMeta(4,1), foldedMeta(5,1))
seeds.orig <- c(rep(1,2), rep(47,2), rep(100,2), rep(99,2), rep(3,2))
origpaths <- rep(c("CD4", "CD8"), 5)
```

```{r compass-orig, options}

# cl <- makeCluster(10) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:10, .packages = c("dplyr", "COMPASS")) %dopar% {
# 
# COMPASS_orig(NS.orig[[i]], NU.orig[[i]], "SAMPLE ID",
#              meta.orig[[i]], 20000, seeds.orig[[i]],
#              paste0("/work/fwh6/COVID/out/200000/orig/",origpaths[i]), "orig")
# 
# }
# 
# stopCluster(cl) # stop the cluster
```

# Results

We look at the following graphs:

- Heatmaps 
- Polyfunctional scores

### Comparing to Original COMPASS results

The original COMPASS results appear to match the COMPASS heatmap generated from the github object but is missing a few gates at 20000 iterations. The COMPASS-covariate object, even with 20000 runs, seems to add gates to be considered. In the training data, the resulting PFS scores seem more well-separated using COMPASS-covariate in comparison to original COMPASS.

```{r compare, options}

my_palette <- pal_igv("default", alpha=0.7)(15)

#--------------------------------------------------------
# The paper CD4 run
#--------------------------------------------------------

rownames(CD4$data$meta) <- CD4$data$meta$`SAMPLE ID`
png(file=file.path(parentDirectory,"2-Output/COVID_CD4_paper.png"),
    width=500, height = 750)
plot.COMPASSResult.ComplexHeatmap(CD4,
                                  row_annotation = "Cohort",
                                  row_annotation_colors = list("Non-hospitalized"=my_palette[11],
                                                               "Hospitalized" = my_palette[5]))
dev.off()

#--------------------------------------------------------
# Original COMPASS run
#--------------------------------------------------------

CD4OrigCOMPASS_run <- readRDS("/work/fwh6/COVID/out/200000/orig/CD4/orig20000_seed1.rds")

rownames(CD4OrigCOMPASS_run$COMPASSobj$data$meta) <- CD4OrigCOMPASS_run$COMPASSobj$data$meta$`SAMPLE ID`
plot.COMPASSResult.ComplexHeatmap(CD4OrigCOMPASS_run$COMPASSobj, 
                                  row_annotation = "Cohort",
                                  row_annotation_colors = list("Non-hospitalized"=my_palette[11],
                                                               "Hospitalized" = my_palette[5]))

#--------------------------------------------------------
# COMPASS-covariate run
#--------------------------------------------------------

CD4CovarCOMPASS_run <- readRDS("/work/fwh6/COVID/out/200000/covar/all_vars/unlog/CD4/covar20000_seed1.rds")

# rownames(CD4CovarCOMPASS_run$COMPASScovarobj$data$meta) <- CD4OrigCOMPASS_run$COMPASSobj$data$meta$`SAMPLE ID`
# return as fit-data list
covarTest <- COVtoCOMPASSObj(CD4CovarCOMPASS_run, 
                CD4OrigCOMPASS_run,
                CD4surfaceMat)
plot.COMPASSCovarResult.ComplexHeatmap(covarTest,
                                       row_annotation = "Cohort",
                                  row_annotation_colors = list("Non-hospitalized"=my_palette[11],
                                                               "Hospitalized" = my_palette[5]))

#--------------------------------------------------------
# PFS comparison
#--------------------------------------------------------

# testPFSDF <- getPFSDF(CD4OrigCOMPASS_run$COMPASSobj, covarTest)
# testPFSDF %>%
#   ggplot(aes(x=Cohort, y=PFS)) + geom_boxplot() +
#   facet_wrap(.~COMPASS.Type)
```

### All-vars vs. PCA

We compare the following performance measures among runs using all-var unlogged covariates, PCA covariates, all-var logged covariates:

- Train and Test ROC (over five folds separately)
- Train boxplots of PFS score
- Convergence statistics like Geweke's

We first read in the CD4 COMPASS-covar and original objects in as lists.

```{r read-in-COMPASSobjs, options}

CD4Objs_all_vars_log <- readInObjs("/work/fwh6/COVID/out/200000/covar/all_vars/log/CD4/",
                      pattern="covar20000_seed.*")

CD4Objs_all_vars_unlog <- readInObjs("/work/fwh6/COVID/out/200000/covar/all_vars/unlog/CD4/",
                      pattern="covar20000_seed.*")

CD4Objs_pca <- readInObjs("/work/fwh6/COVID/out/200000/covar/pca/log/CD4/",
                      pattern="covar20000_seed.*")

CD4Orig <- readInObjs("/work/fwh6/COVID/out/200000/orig/CD4/",
                      pattern="orig20000_seed.*")

#--------------------------------------------------------
# Plot heatmaps
#--------------------------------------------------------
my_palette <- pal_igv("default", alpha=0.7)(15)
for(i in 1:5) {plotHeatM(CD4Objs_all_vars_log[[i]], CD4Orig[[i]], CD4surfaceMat_log,
          paste0(parentDirectory,"2-Output/All-Var-Log/COVID_CD4_log_allvar_seed", names(CD4Orig)[[i]],".png"),
           "Cohort", list("Hospitalized"=my_palette[11],
                                    "Non-hospitalized"=my_palette[12])) }

for(i in 1:5) {plotHeatM(CD4Objs_all_vars_unlog[[i]], CD4Orig[[i]], CD4surfaceMat,
          paste0(parentDirectory,"2-Output/All-Var-Unlog/COVID_CD4_unlog_allvar_seed", names(CD4Orig)[[i]],".png"),
           "Cohort", list("Hospitalized"=my_palette[11],
                                    "Non-hospitalized"=my_palette[12])) }

for(i in 1:5) {plotHeatM(CD4Objs_pca[[i]], CD4Orig[[i]], CD4surfaceMat_PCA,
          paste0(parentDirectory,"2-Output/PCA/COVID_CD4_pca_seed", names(CD4Orig)[[i]],".png"),
           "Cohort", list("Hospitalized"=my_palette[11],
                                    "Non-hospitalized"=my_palette[12])) }

#--------------------------------------------------------
# Making covar output into COMPASSObj-like list
#--------------------------------------------------------
# origTest <- CD4Orig[[1]]$COMPASSobj
# covarTest <- COVtoCOMPASSObj(CD4Objs_all_vars_log[[1]], CD4Orig[[1]], CD4surfaceMat_log)

#--------------------------------------------------------
# Calculate PFS and add PFS column to meta DF
#--------------------------------------------------------
# PFSDFcovarTest <- getPFSDF(covarTest)
# PFSDForigTest <- getPFSDF(origTest)
# 
# PFSdf <- PFSDFcovarTest %>%
#   bind_rows(PFSDForigTest)

# covarTest$data$meta <- covarTest$data$meta %>%
#   inner_join(PFSDFcovarTest %>% rename("SAMPLE ID"=ID))
# 
# origTest$data$meta <- origTest$data$meta %>%
#   inner_join(PFSDForigTest %>% rename("SAMPLE ID"=ID))

#--------------------------------------------------------
# Paired boxplot for PFS change btwn covar and original
#--------------------------------------------------------

# PFSdf %>%
#   ggplot(aes(x=COMPASS.Type, y=PFS)) + geom_boxplot() +
#   geom_line(aes(group=ID, color=Cohort),alpha=0.5) +facet_wrap(.~Cohort)


# ggsave(filename = file.path(parentDirectory,"2-Output/scaled_CD8COVID_PFS.png"),
#        height = 5, width = 6)

# wilcox.test(PFSdf %>% filter(Cohort=="Hospitalized", COMPASS.Type == "PFSCovar") %>% .$PFS, PFSdf %>% filter(Cohort=="Non-hospitalized", COMPASS.Type == "PFSCovar") %>% .$PFS)
# 
# wilcox.test(PFSdf %>% filter(Cohort=="Hospitalized", COMPASS.Type == "PFSOrig") %>% .$PFS, PFSdf %>% filter(Cohort=="Non-hospitalized", COMPASS.Type == "PFSOrig") %>% .$PFS)

``` 


```{r orig-plot, options}

# rownames(origTest$data$meta) <- rownames(origTest$fit$mean_gamma)
# #--------------------------------------------------------
# # Plotting using Malisa's complexheatmap function
# #--------------------------------------------------------
# png(file=file.path(parentDirectory,"2-Output/Original/COVID_CD4_orig_seed1.png"),
#     width=500, height = 750)
# origplot <- plot.COMPASSResult.ComplexHeatmap(origTest,
#                                   row_annotation = "Cohort",
#                                   row_annotation_colors = list(
#                                     "Hospitalized"=my_palette[11],
#                                     "Non-hospitalized"=my_palette[12]))
# draw(origplot)
# dev.off()
```

### Beta Heatmap

We see which covariates are associated with various gates. 

```{r beta-hm, options}
# mean_beta <- rowMeans(covarTest$fit$beta, dim=2)
# 
# Heatmap(mean_beta, cluster_rows = FALSE,
#                           show_row_dend = FALSE,
#                           cluster_columns = FALSE, cluster_column_slices = FALSE)


```


### Convergence

We compare the acceptance rates of COMPASS vs. COMPASS-covariate. We plot the Geweke's, Raftery and Lewis, and Heidelberg and Welch statistic for the two gates' patients' gamma values.

```{r convergence, options}
# cbind(x=origTest$fit$A_gamma, y=covarTest$fit$A_gamma) %>%
#   as.data.frame() %>%
#   ggplot(aes(x=x,y=y)) +
#   geom_point() +
#   geom_abline() +
#   xlab("Original COMPASS Acceptance Rate") +
#   ylab("COMPASS-covar Acceptance Rate") +
#   ggtitle("Gamma Acceptance Rates")
```

### Regression

We use a regression to predict the status (hospitalized vs. non-hospitalized) based on the PFS, sex, race, and age of a patient.

To test each fold's ability to estimate PFS/FS for each test patient, we 
1. We pull beta samples from the train beta posterior for each of the test samples. 
2. We predict gamma by multiplying Luminex level by the beta sample coefficient (and adding beta sample intercept), then taking inverse logit.
2. We use gamma to calculate estimated PFS and FS for test.

#### Sampling Beta

We sample entire beta matrices and calculate the mean beta matrix. We then multiply by the covariate test matrix and inverse-logit to get the mean gamma matrix for the test patients. The mean gamma matrix is used to find the estimated PFS for each patient.

```{r regression, options}
#--------------------------------------------------------
# Making covar output into COMPASSObj-like list
#--------------------------------------------------------
# folds need to be ordered by first seed digit: 1, 100, 3, 47, 99
# seeds were done in order initially: 1, 47, 100, 99, 3
foldsIdxnew <- sapply(names(CD4Orig), as.numeric)
foldsCD4new <- foldsCD4[c(1, 3, 5, 2, 4)]
# origTest <- CD4Orig[[1]]$COMPASSobj
# covarTest <- COVtoCOMPASSObj(CD4Objs_all_vars_log[[1]], CD4Orig[[1]], CD4surfaceMat_log)
# 
# # get test meta DF plus PFS
# testMetaObj <- testMetawPFS(foldsCD4,1, CD4meta, CD4surfaceMat_log, covarTest, "SAMPLE ID")
# 
# testMetaObj
```


#### Train Regression

We train regressions on the original and covariate datasets.

```{r label, options}
# origTestCovs <- origTest$data$meta %>%
#   inner_join(PFSDForigTest %>% rename("SAMPLE ID"=ID)) %>%
#   select(Cohort, Age, Sex, PFS) %>%
#   mutate(Cohort_Bin = if_else(Cohort=="Hospitalized", 1, 0))
# 
# origTestMod <- glm(Cohort_Bin~ PFS,
#     data=origTestCovs,
#     family="binomial")
# 
# summary(origTestMod)

# covarTestCovs <- covarTest$data$meta %>%
#   select(Cohort, Age, Sex, PFS) %>%
#   mutate(Cohort_Bin = if_else(Cohort=="Hospitalized", 1, 0))
# 
# covarTestMod <- glm(Cohort_Bin~ Age + Sex + PFS,
#     data=covarTestCovs,
#     family="binomial")
# 
# summary(covarTestMod)
# trainMod <- getTrainReg(foldsCD4new, 1, CD4meta, CD4surfaceMat, covarTest,"SAMPLE ID")
# summary(trainMod)
# testProbs <- getResponseProbs("test",foldsCD4new, 1, CD4meta, CD4surfaceMat, covarTest,"SAMPLE ID")
# trainProbs <- getResponseProbs("train",foldsCD4new, 1, CD4meta, CD4surfaceMat, covarTest,"SAMPLE ID")
```

#### Test Regression

Since we have around 10 hospitalized and 20 hospitalized patients in each training set, we stick to only including PFS in a logistic regression with infection. The train-test regression results are below for all-vars logged, all-vars unlogged, and PCA respectively. PCA appears to have the best test AUC.

```{r test-reg, options}
# origTestPreds <- predict(origTestMod, newdata=testMeta, type="response")
# roc(testMeta %>% mutate(Cohort_Bin=(Cohort=="Hospitalized")*1) %>% .$Cohort_Bin, origTestPreds)

# get ROC
# getROCs(setdiff(1:nrow(CD4meta), foldsCD4[[1]]), CD4meta, testProbs)$auc
# getROCs(foldsCD4[[1]], CD4meta, trainProbs)$auc

# can't use 5th since all nonhospitalized
# fold_result(5, foldsCD4new, CD4Orig, CD4Objs_all_vars_log, rep(list(CD4surfaceMat_log),5),
#             rep(list(CD4meta),5))

logRegResults <- do.call(rbind,lapply(1:4, function(x) fold_result(x, foldsCD4new, CD4Orig, CD4Objs_all_vars_log, rep(list(CD4surfaceMat_log),5),
            rep(list(CD4meta),5)))) 

avgRegVals(logRegResults, "Logged All-Var")

kable(logRegResults) %>%
  kable_classic_2()

unlogRegResults <- do.call(rbind,lapply(1:4, function(x) fold_result(x, foldsCD4new, CD4Orig, CD4Objs_all_vars_unlog, rep(list(CD4surfaceMat),5),
            rep(list(CD4meta),5))))

avgRegVals(unlogRegResults, "Unlogged All-Var")

kable(unlogRegResults) %>%
  kable_classic_2()


PCARegResults <- do.call(rbind,lapply(1:4, function(x) fold_result(x, foldsCD4new, CD4Orig, CD4Objs_pca, rep(list(CD4surfaceMat_PCA),5),
            rep(list(CD4meta),5))))

avgRegVals(PCARegResults, "Logged PCA")

kable(PCARegResults) %>%
  kable_classic_2()
```
