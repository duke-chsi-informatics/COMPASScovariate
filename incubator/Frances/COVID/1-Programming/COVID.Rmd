---
title: "COVID"
output: html_document
date: "2023-05-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(COMPASS)
library(doParallel)
library(corrplot)
library(glmnet)
library(kableExtra)
library(broom)
library(PCAtools)
library(caret)
library(RColorBrewer)
library(circlize)
library(pROC)
library(ggsci)
library(Rcpp)

source("~/CHSI/PackageDev/COMPASScovariate/R/COMPASS-covariate.R")
source("~/CHSI/PackageDev/COMPASScovariate/R/updatebeta.R")
source("~/CHSI/PackageDev/COMPASScovariate/R/Scores.R")
source("~/CHSI/PackageDev/COMPASScovariate/R/utils.R")
source("~/CHSI/PackageDev/COMPASScovariate/incubator/Frances/helperscripts.R")

parentDirectory <- "~/CHSI/PackageDev/COMPASScovariate/incubator/Frances/COVID/"
```

## COVID Read-in

We get the counts matrices from COMPASS objects saved here: https://github.com/seshadrilab/Correlates_Severe_COVID19_ICS/tree/master/out/CompassOutput/4%2B/NCAP

The antibody data is here: https://github.com/seshadrilab/Correlates_Severe_COVID19_Surface_Markers/tree/master/processed_data

From the paper:

"To ensure the detection of polyfunctional T cell subsets that may be present at low frequencies, we employed Combinatorial Polyfunctionality Analysis of Antigen-Specific T Cell Subsets (COMPASS) (38). Among 128 possible functional profiles, we detected 21 antigen-specific CD4+ T cell subsets across all 4 peptide pool stimulations (Figure 3A). Notably, the probability of detecting a particular response varied according to the antigen. For example, several profiles containing 3 or 4 functions were readily detected after stimulation with S1, S2, or N but not E. However, the 2 profiles containing 5 functions (IFN-γ, IL-14/5/13, TNF, IL-2, and CD40L) were only detected after stimulation with S1. Stimulation with E resulted in a CD107a monofunctional profile that was also observed after stimulation with S2 (Figure 3A)."

- Functional diversity of CD4+ T cell responses to SARS-CoV-2 are associated with hospitalization.

On antibodies: "Archived serum was used to compare neutralizing antibody titers, as well as Ig levels, Fc receptor (FcR) binding, and Fc effector functions targeting full spike (S), S1, S2, receptor binding domain (RBD), and nucleocapsid (N) proteins...Antibody functional profiles are associated with hospitalization after COVID-19. To follow up these differences in Ig subclass, we examined several Fc-binding specificities and Fc-dependent effector functions. Fc-receptors (FcRs) specificities FcR2A, FcR2B, FcR3A, and FcR3B binding S, S1, S2, RBD, and N were significantly higher among hospitalized subjects (Supplemental Figure 2B). Antibody-dependent cellular phagocytosis (ADCP), antibody-dependent neutrophil phagocytosis (ADNP), and antibody-dependent complement deposition (ADCP) against S, RBD, and N was significantly increased among hospitalized subjects (Figure 2A). Notably, while MIP-1β secretion by NK cells was increased among hospitalized subjects, NK cell degranulation measured by CD107a expression was elevated among nonhospitalized subjects (Figure 2B). To obtain a qualitative summary of the differences in antigen-specific humoral responses between groups, we visualized Ig subclass, Fc-binding specificity, and Fc-effector functions targeting S, RBD, and N using nightingale rose graphs (Figure 2C). The results show consistently higher levels of measured analytes among hospitalized subjects, with the exception of CD107a expression on NK cells. We next examined the correlation of antibody profiles independently in hospitalized and nonhospitalized subjects. The correlation with neutralization titers in both groups was low, supporting our analysis of nonredundant aspects of the SARS-CoV-2–specific antibody response. This was surprising, given previous findings that IgG antibodies to RBD are correlated with neutralization titers (34, 35). Relative to nonhospitalized subjects, hospitalized subjects demonstrated lower correlation among antibody titers, Fc-specificities, and Fc-effector functions (Figure 2D). This difference was robust to subsampling in order to account for the unequal sample sizes in each group (Supplemental Figure 3). Finally, we calculated a polyfunctionality score for each individual for S, RBD, and N over the 6 antibody functionality readouts against 3 SARS-CoV-2 antigens. Subjects with comorbidities were able to activate a robust polyfunctional antibody response against S, RBD, and N in comparison with subjects without comorbidities (Figure 2E)." 

We don't have antibody data access, unfortunately, so let's turn to more flow parameters:

"In our matched cross-sectional analysis, we noted that the frequency of CD3+, CD4+, and CD8+ T cells did not vary significantly over time since symptom onset or between hospitalized and nonhospitalized subjects (Figure 1, D–F, and Supplemental Figures 1C). We also found no difference in the frequency of γδ T cells, iNKT cells, or MAIT cells or in B cells, monocytes, or NK cells (Figure 1G and Supplemental Figure 5, A and B). However, the frequency of activated CD8+ T cells was significantly higher among hospitalized subjects, which is consistent with prior reports (Figure 1F) (19, 36, 37). The frequency of naive CD8+ T cells was also lower among hospitalized subjects, suggesting increased differentiation to an effector phenotype in severe COVID-19; however, no difference in the frequency of naive CD4+ T cells was observed between groups (Figure 1H). Among total γδ T cells, the frequency of activated γδ T cells was higher among hospitalized subjects independent of expression of the Vδ2 gene segment (Figure 1I)."

There are 20 hospitalized patients and 40 non-hospitalized (3 are healthy controls from pre-COVID times). "For the ICS panel, data from 20 convalescent hospitalized and 37 convalescent nonhospitalized subjects were ultimately analyzed. For the surface marker panel, data from 15 convalescent hospitalized and 36 convalescent nonhospitalized subjects were analyzed."

As a covariate(s) we can consider using the antibodies included in the


### Extract Count Matrices, Antibody data, and Metadata

We first get the stimulated and unstimulated count matrices, antibody data, and metadata for the 60 patients in question. There are 20 hospitalized, 37 non-hospitalized, and 3 healthy control patients.

There are 23 CD4+ gates and 12 CD8+ gates included in the COMPASS analysis.



```{r read-in, options}

CD4 <- readRDS(file.path(parentDirectory,"0-Data/Raw/COMPASSResult_4+_NCAP.rds"))

CD4ns <- CD4$data$n_s
CD4nu <- CD4$data$n_u

CD4$data$meta %>%
  drop_na() %>%
  count(Cohort)

CD8 <- readRDS(file.path(parentDirectory,"0-Data/Raw/COMPASSResult_8+_NCAP.rds"))

CD8ns <- CD8$data$n_s
CD8nu <- CD8$data$n_u

```


There are fewer patients in the flow surface dataset than the flow ICS dataset (51, which matches with what the paper says). However, a couple of those additionally don't appear in the flow dataset, leaving us with a set of 49 common samples for CD4 and 48 common samples for CD8.

The paper found that HLADR/CD38 CD8, naive CD8, HLADR/CD38 GD, HLADR?CD38 GD/VD2+ proportions were associated with hospitalization. For COMPASS-covariate, we get rid of flow surface variables which have correlation more than 0.8. We then test three sets of covariates derived as follows:

1. Log the covariates and keep all of them.
2. Log the covariates and use PCA to keep the first 10 components
3. Don't log the covariates and keep all of them.

### Check Correlation of Surface Markers

The large correlations with absolute value more than 0.8 include:

- Monocytes_Lymphocytes_ratio vs. Monocytes_pct_Live
- CD8_pct_T vs. CD4_pct_T
- HLADR_CD38_pct_CD4 vs. HLADR_CD38_pct_CD8
- HLADR_CD38_pct_CD8 vs. HLADR_CD38_pct_GD_Vd2Neg

In addition to the CD4_CD8_ratio, GD_pct_T, HLADR_CD38_pct_GD (the redundant covariates), we get rid of Monocytes_pct_Live, CD4_pct_T, HLADR_CD38_pct_CD4, HLADR_CD38_pct_GD_Vd2Neg.

```{r corr-surface, options}
#--------------------------------------------------------
# Checking correlation
#--------------------------------------------------------

surfaceDF <- read.csv(file.path(parentDirectory, "0-Data/Raw/antibodiesCOVID.csv"))  

surfaceDF %>% select(-SAMPLE_ID) %>% as.matrix() %>% cor() %>%
  corrplot(method = 'number',
           tl.cex = 0.5,
           number.cex=0.5)

rm(surfaceDF)
```


### Split Train-Test Covariate Matrices for Transformation

In this section, we will use folds created using the caret package to divide the covariate matrices into train-test and transform training only. The scaleCenterTest and PCATest functions will be used to transform the test covariates according to the train covariates.

```{r todo, options}
surfaceDF <- read.csv(file.path(parentDirectory, "0-Data/Raw/antibodiesCOVID.csv")) %>%
  #redundant columns
  select(-c(CD4_CD8_ratio, GD_pct_T, HLADR_CD38_pct_GD,
            Monocytes_pct_Live, CD4_pct_T, HLADR_CD38_pct_CD4, HLADR_CD38_pct_GD_Vd2Neg))

# patients who have both antibody and counts info
CD4finalPats <- intersect(CD4$data$meta %>% drop_na() %>% .$`SAMPLE ID`,
                          surfaceDF$SAMPLE_ID)

CD4surfaceDF <- surfaceDF %>% filter(SAMPLE_ID %in% CD4finalPats) %>%
  # arrange to be in same order as CD4 objects
  arrange(factor(SAMPLE_ID,CD4finalPats))

set.seed(47)
CD4Parts <- createDataPartition(CD4$data$meta %>% filter(`SAMPLE ID` %in% CD4finalPats) %>% .$Cohort, p=0.8, times=5)

#--------------------------------------------------------
# Train surface marker matrices (unlogged and logged)
#--------------------------------------------------------

CD4surfaceDFs.train <- lapply(CD4Parts, function(x) CD4surfaceDF[x,] %>% 
                                `rownames<-`(c(.$SAMPLE_ID)) %>%
                                select(-SAMPLE_ID))
CD4surfaceDFs.unlog <- lapply(CD4surfaceDFs.train, function(x) x %>% 
  mutate(across(everything(), ~scale(.x))))
CD4surfaceDFs.log <- lapply(CD4surfaceDFs.train, function(x) x %>% 
  mutate(across(everything(), ~scale(log(.x + 1)))))

#--------------------------------------------------------
# Test surface markers
#--------------------------------------------------------
CD4surfaceDFs.test <- lapply(CD4Parts, function(x) CD4surfaceDF[-x,] %>% 
                                `rownames<-`(c(.$SAMPLE_ID)) %>%
                                select(-SAMPLE_ID))
CD4surfaceDFs.test.unlog <- lapply(1:5, function(i)
  scaleCenterTest(CD4surfaceDFs.train[[i]], CD4surfaceDFs.test[[i]]))
CD4surfaceDFs.test.log <- lapply(1:5, function(i)
  scaleCenterTest(CD4surfaceDFs.train[[i]] %>% mutate(across(everything(), ~log(.x+1))), 
                  CD4surfaceDFs.test[[i]] %>% mutate(across(everything(), ~log(.x+1)))))

```

We also do the same covariate transformations for the full set of available observations:

```{r full-covars, options}
CD4surfaceDF.full.unlog <- CD4surfaceDF %>% 
  `rownames<-`(c(.$SAMPLE_ID))%>% 
  select(-SAMPLE_ID) %>%
  mutate(across(everything(), ~scale(.x)))
CD4surfaceDF.full.log <- CD4surfaceDF %>% 
  `rownames<-`(c(.$SAMPLE_ID))%>% 
  select(-SAMPLE_ID) %>%
  mutate(across(everything(), ~scale(log(.x + 1))))
```


Checking the surface distributions:

```{r surface-dist, options}
CD4surfaceDF.full.unlog %>%
  rownames_to_column(var="SAMPLE_ID") %>%
  pivot_longer(-SAMPLE_ID, names_to = "VarName", values_to="Value") %>%
  ggplot(aes(x=Value)) + geom_histogram() +
  facet_wrap(.~VarName, scales = "free")
```

And the transformed antibody distributions:

```{r trans-surface, options}
CD4surfaceDF.full.log %>%
  rownames_to_column(var="SAMPLE_ID") %>%
  pivot_longer(-SAMPLE_ID, names_to = "VarName", values_to="Value") %>%
  ggplot(aes(x=Value)) + geom_histogram() +
  facet_wrap(.~VarName, scales = "free")
```

### PCA

For PCA we first log and scale/center the train and test sets separately (unlike above, where we scale/center based on the train mean and SD). We then get loadings from the training data and apply those loadings to the test data to get transformed PCs.

```{r pca-logged, options}
CD4surfaceDFs.test.log.forPCA <- lapply(CD4surfaceDFs.test, function(x) x %>% 
  mutate(across(everything(), ~scale(log(.x + 1)))))

#--------------------------------------------------------
# Train and test PCA-transformed surface markers 
# PCAtools package has misleading name: the rotated matrix is really loading
#--------------------------------------------------------

CD4surfaceDFs.pca <- lapply(CD4surfaceDFs.log, function(x) {
  p <- prcomp(x, center=FALSE) 
  p$x %>% as.data.frame() %>%
    select(PC1:PC10) 
  })

# we take the rotated matrix (markers x PCs) and multiply by the test markers (obs x markers)
CD4surfaceDFs.test.pca <- lapply(1:5,
                                 function(i) PCATest(CD4surfaceDFs.log[[i]],
                                                     CD4surfaceDFs.test.log.forPCA[[i]]))

p <- pca(CD4surfaceDFs.log[[1]])
screeplot(p)
biplot(p, showLoadings = TRUE, showLoadingsNames = TRUE,
    labSize = 5, pointSize = 5, sizeLoadingsNames = 5)

#--------------------------------------------------------
# Full PCA-transformed covariate matrix
#--------------------------------------------------------

CD4surfaceDF.full.pca <- prcomp(CD4surfaceDF.full.log,center=FALSE)$x %>%
  as.data.frame() %>% select(PC1:PC10)
```

# Running COMPASS with the 49 Patients

We run COMPASS on the 49 patients. First, the count matrices and metadata are subsetted to include only the 49 patients of interest.

```{r compass-funcs, options}

#------------------------------------------------------
# FUNCTION for getting categories matrix for flow counts
# @params: flow DF
# @output: category matrix
#------------------------------------------------------
getCats <- function(stim) {
  # finding marker names and making category count matrix
marker_names <- unique(
    unlist( strsplit( gsub("!", "", colnames(stim)), "&", fixed=TRUE ) )
  )
  n_markers <- length(marker_names)

  cats <- as.data.frame( matrix(0, nrow=ncol(stim), ncol=length(marker_names)))
  rownames(cats) <- colnames(stim)
  colnames(cats) = marker_names

  for (i in seq_along(cats)) {
    #cats[, i] <- as.integer(grepl( paste0( colnames(cats)[i], "+" ), rownames(cats), fixed=TRUE ))
    cats[,i] <-
      as.integer(!grepl(paste0("!",colnames(cats)[i],"(&|$)+"),rownames(cats),fixed =
                          FALSE))
  }
  cats$Counts <- apply(cats, 1, sum)
  
  cats <- as.matrix(cats)
}

#-------------------------------------------------------------------------
# FUNCTION for COMPASS 
# takes in flow data frame, metadata, iterations, suffix for naming rds file, train index (from meta)
# TODO: fix to use COMPASS discrete? can we omit test_index by using PTID to get it later?
#-------------------------------------------------------------------------
COMPASS_orig <- function(n_s, n_u, individual_id, meta, iter, seed, outdir, dataName) {
  
  # n_s (I x K), n_u (I x K), iters, replications, X (I x J)
  starttime = Sys.time()
  COMPASSobj <- SimpleCOMPASS(n_s = n_s,
                                   n_u = n_u,
                                   meta=meta,
                                   individual_id = individual_id,
                                   iterations = iter,
                                   replications = 7)
  endtime= Sys.time()

saveRDS(list(COMPASSobj = COMPASSobj, runTime = endtime-starttime),
           paste0(outdir, "/", dataName, iter, "_seed", seed,".rds"))

  
rm(COMPASSobj)

}


#-------------------------------------------------------------------------
# FUNCTION for COMPASS covariate
# takes in flow data frame, covariate data frame, iterations, suffix for naming rds file, train index, seed
#-------------------------------------------------------------------------
COMPASS_covar <- function(n_s, n_u, X, categories, iter, seed, outdir, dataName) {

  # n_s (I x K), n_u (I x K), iters, replications, X (I x J)
  starttime = Sys.time()
  COMPASScovarobj <- .COMPASS.covariate(n_s=n_s, n_u=n_u,
                                         categories = categories,
                                         iterations = iter, replications = 7, X = X)
  endtime= Sys.time()

saveRDS(list(COMPASScovarobj = COMPASScovarobj, runTime = endtime-starttime),
          paste0(outdir, "/", dataName, iter, "_seed", seed,".rds"))

rm(COMPASScovarobj)

}


#########################################################
# FUNCTION for running COMPASS and COMPASS-covar for one seed
# @param
#########################################################
runCOMPASS<- function(n_s, n_u, individual_id, meta, X, categories, iter, seed, outdirorig, outdircovar, dataName) {
  COMPASS_orig(n_s, n_u, individual_id, meta, iter, seed, outdirorig, dataName)
  COMPASS_covar(n_s, n_u, X, categories, iter, seed, outdircovar, paste0(dataName, "covar"))
}
```



```{r COMPASS-prep, options}
#--------------------------------------------------------
# ns, nu, and meta are ordered the same
#--------------------------------------------------------

CD4ns_final <- CD4ns[rownames(CD4ns) %in% CD4finalPats,]
CD4nu_final <- CD4nu[rownames(CD4nu) %in% CD4finalPats,]
# all(rownames(CD4ns_final)==rownames(CD4nu_final))

CD4meta <- CD4$data$meta[CD4$data$meta$`SAMPLE ID` %in% CD4finalPats,]
# all(rownames(CD4ns_final)==CD4meta$`SAMPLE ID`)

# CD4surfaceMat <- surfaceDF[surfaceDF$SAMPLE_ID %in% CD4finalPats,] %>%
#   `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
#   .[rownames(CD4ns_final),]
# # all(rownames(CD4ns_final)==rownames(CD4surfaceMat))
# 
# CD4surfaceMat_log <- surfaceDF_logged[surfaceDF_logged$SAMPLE_ID %in% CD4finalPats,] %>%
#   `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
#   .[rownames(CD4ns_final),]
# 
# CD4surfaceMat_PCA <- PCA_df_logged[PCA_df_logged$SAMPLE_ID %in% CD4finalPats,] %>%
#   `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
#   .[rownames(CD4ns_final),]

#--------------------------------------------------------
# CD8 inputs
#--------------------------------------------------------

# CD8ns_final <- CD8ns[rownames(CD8ns) %in% CD8finalPats,]
# CD8nu_final <- CD8nu[rownames(CD8nu) %in% CD8finalPats,]
# 
# CD8meta <- CD8$data$meta[CD8$data$meta$`SAMPLE ID` %in% CD8finalPats,]

# CD8surfaceMat <- surfaceDF[surfaceDF$SAMPLE_ID %in% CD8finalPats,] %>%
#   `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
#   .[rownames(CD8ns_final),]
# 
# CD8surfaceMat_log <- surfaceDF_logged[surfaceDF_logged$SAMPLE_ID %in% CD8finalPats,] %>%
#   `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
#   .[rownames(CD8ns_final),]
# 
# CD8surfaceMat_PCA <- PCA_df_logged[PCA_df_logged$SAMPLE_ID %in% CD8finalPats,] %>%
#   `rownames<-`(.$SAMPLE_ID) %>% select(-SAMPLE_ID) %>% as.matrix() %>%
#   .[rownames(CD8ns_final),]
```

### Full Runs

We run COMPASS-original and the three variants of COMPASS-covariate on the full set of 49 variables.

```{r full-covar, options}
# full.NS <- rep(list(CD4ns_final), 3)
# full.NU <- rep(list(CD4nu_final), 3)
full.covMatrices <- list(CD4surfaceDF.full.unlog, CD4surfaceDF.full.log, CD4surfaceDF.full.pca)
full.covpaths <- c("all_vars/unlog/CD4/full", "all_vars/log/CD4/full", "pca/log/CD4/full")
# full.CAT <- rep(list(getCats(CD4ns_final)), 3)
# cl <- makeCluster(3) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:3, .packages = c("dplyr", "COMPASS")) %dopar% {
#   # runCOMPASS(CD4ns_final, CD4nu_final, "SAMPLE ID",
#   #            CD4meta, covMatrices[j], getCats(CD4ns_final),
#   #            iter=2000, seed=seeds[i], "/work/fwh6/COVID/out/2000/orig",
#   #            "/work/fwh6/COVID/out/2000/covar", "CD4_COMPASStest_test")
# 
# 
#   COMPASS_covar(full.NS[[i]],
#                 full.NU[[i]], full.covMatrices[[i]] %>% as.matrix(),
#                 full.CAT[[i]],
#                 iter=40000, seed=47,
#                 paste0("/work/fwh6/COVID/out/40000/covar/",full.covpaths[i]),
#                 "covar")
# }
# 
# stopCluster(cl) # stop the cluster
```


The run for COMPASS-orignal:

```{r orig-full, options}
# orig.full.iter <- 40000
# COMPASS_orig(CD4ns_final, CD4nu_final, "SAMPLE ID",
#              CD4meta, orig.full.iter, 47,
#              "/work/fwh6/COVID/out/40000/orig/CD4/full/", "orig")
```

### Dividing into Test-Train

We make a list of parameter combinations to test:

- folds (CD4-fold-1 (x3), ..., CD4-fold-5 (x3))
- cov matrices (CD4 unlog, CD4 log, CD4 PCA): 5 folds
- NS (fold-1 (x3)...fold-5 (x3))
- NU (fold-1 (x3)...fold-5 (x3))
- categories: (CD4 (x3)) x5

```{r test-train, options}
set.seed(47)
# foldsCD4 <- createFolds(CD4meta$`SAMPLE ID`, k=5, list=TRUE, returnTrain = TRUE)
# foldsCD8 <- createFolds(CD8meta$`SAMPLE ID`, k=5, list=TRUE, returnTrain = TRUE)



foldedNs <- function(type="train", foldNum, reps) {
  if(type=="train") {
    c(rep(list(CD4ns_final[CD4Parts[[foldNum]],]),reps)) }
  else {
    c(rep(list(CD4ns_final[-CD4Parts[[foldNum]],]),reps))
  }
}

foldedNu <- function(type="train", foldNum, reps) {
  if(type=="train") {
    c(rep(list(CD4nu_final[CD4Parts[[foldNum]],]),reps)) }
  else {
    c(rep(list(CD4nu_final[-CD4Parts[[foldNum]],]),reps))
  }
}

foldedMeta <- function(type="train",foldNum, reps) {
  if(type=="train") {
    c(rep(list(CD4meta[CD4Parts[[foldNum]],]),reps)) }
  else {
    c(rep(list(CD4meta[-CD4Parts[[foldNum]],]),reps))
  }
}

# categories
CAT <- rep(list(getCats(CD4ns_final)), 15)

# Ns and Nu for each simulation
NS <- c(foldedNs(type="train", 1, 3), foldedNs(type="train", 2, 3), foldedNs(type="train", 3, 3), foldedNs(type="train", 4,3 ), foldedNs(type="train", 5,3))
NU <- c(foldedNu(type="train", 1,3), foldedNu(type="train", 2,3), foldedNu(type="train", 3,3), foldedNu(type="train", 4,3), foldedNu(type="train", 5,3))

# seeds for each simulation
seeds <- c(rep(1,3), rep(2,3), rep(3,3), rep(4,3), rep(5,3))

# covariate matrix for each simulation
covMatrices <- do.call(c, 
        lapply(1:5,
               function(i) list(CD4surfaceDFs.unlog[[i]], CD4surfaceDFs.log[[i]], CD4surfaceDFs.pca[[i]]))) 

# save paths for each simulation
covpaths <- rep(c("all_vars/unlog/CD4", "all_vars/log/CD4", "pca/log/CD4"),5)
```

We run 6 covariate matrix + T-cell type combinations, crossed with 5 folds for a total of 30 runs of COMPASS-covariate.

```{r compass-covariate-run, options}



# cl <- makeCluster(15) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:15, .packages = c("dplyr", "COMPASS")) %dopar% {
#   # runCOMPASS(CD4ns_final, CD4nu_final, "SAMPLE ID",
#   #            CD4meta, covMatrices[j], getCats(CD4ns_final),
#   #            iter=2000, seed=seeds[i], "/work/fwh6/COVID/out/2000/orig",
#   #            "/work/fwh6/COVID/out/2000/covar", "CD4_COMPASStest_test")
# 
# 
#   COMPASS_covar(NS[[i]],
#                 NU[[i]], covMatrices[[i]] %>% as.matrix(),
#                 CAT[[i]],
#                 iter=40000, seed=seeds[i],
#                 paste0("/work/fwh6/COVID/out/40000/covar/",covpaths[i]),
#                 "covar")
# }
# 
# stopCluster(cl) # stop the cluster

```


We also run COMPASS with the 5 CD4 training sets. We create a new set of simulation parameters for:

- NS (folds taken from previous): CD4-fold-1, CD8-fold-1, CD4-fold-2, etc.
- NU (folds taken from previous): CD4-fold-1, CD8-fold-1, CD4-fold-2, etc
- meta (folds taken from previous): CD4-fold-1, CD8-fold-1, CD4-fold-2, etc
- seeds
- output directory (orig/CD4 or orig/CD8)

```{r compass-orig-setup, options}
NS.orig <- c(foldedNs(type="train", 1, 1), foldedNs(type="train", 2, 1), foldedNs(type="train", 3, 1), foldedNs(type="train", 4,1), foldedNs(type="train", 5,1))
NU.orig <- c(foldedNu(type="train", 1,1), foldedNu(type="train", 2,1), foldedNu(type="train", 3,1), foldedNu(type="train", 4,1), foldedNu(type="train", 5,1))
meta.orig <-c(foldedMeta(type="train", 1,1), foldedMeta(type="train", 2,1), foldedMeta(type="train", 3,1), foldedMeta(type="train", 4,1), foldedMeta(type="train", 5,1))
seeds.orig <- c(rep(1,1), rep(2,1), rep(3,1), rep(4,1), rep(5,1))
origpaths <- rep(c("CD4"), 5)
```

```{r compass-orig, options}

# cl <- makeCluster(5) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:5, .packages = c("dplyr", "COMPASS")) %dopar% {
# 
# COMPASS_orig(NS.orig[[i]], NU.orig[[i]], "SAMPLE ID",
#              meta.orig[[i]], 40000, seeds.orig[[i]],
#              paste0("/work/fwh6/COVID/out/40000/orig/",origpaths[i]), "orig")
# 
# }
# 
# stopCluster(cl) # stop the cluster
```

# Read In Results

We read in the full runs for unlogged, logged, and PCA-transformed COMPASS-covariate (seed 47). These are saved in a named list of COMPASS-covariate objects.

```{r full-data, options}

full.Objs <- vector(mode="list", length=length(full.covpaths))
  # read in full objects
  for (i in 1:length(full.covpaths)) {
    full.file <- list.files(paste0("/work/fwh6/COVID/out/40000/covar/",full.covpaths[i]),
                            pattern="*.rds")
    full.Objs[[i]] <- readRDS(paste0("/work/fwh6/COVID/out/40000/covar/",full.covpaths[i],"/",full.file))

  }
  
full.OG <- readRDS("/work/fwh6/COVID/out/40000/orig/CD4/full/orig40000_seed47.rds")$COMPASSobj

# transforming into COMPASS-like objects
full.Objs <- lapply(1:3, function(i) COVtoCOMPASSObj(full.Objs[[i]], full.OG, full.covMatrices[[i]]))
names(full.Objs) <- str_extract(full.covpaths,"(.*\\/.*)\\/.*\\/.*",group=1)
```

For regression, we read in the train-test sets:

```{r cv-readin, options}
CD4Objs_all_vars_log <- readInObjs("/work/fwh6/COVID/out/40000/covar/all_vars/log/CD4/",
                      pattern="covar40000_seed.*")

CD4Objs_all_vars_unlog <- readInObjs("/work/fwh6/COVID/out/40000/covar/all_vars/unlog/CD4/",
                      pattern="covar40000_seed.*")

CD4Objs_pca <- readInObjs("/work/fwh6/COVID/out/40000/covar/pca/log/CD4/",
                      pattern="covar40000_seed.*")

CD4Orig <- readInObjs("/work/fwh6/COVID/out/40000/orig/CD4/",
                      pattern="orig40000_seed.*")
```

# Results

We look at the following graphs:

- Heatmaps 
- Polyfunctional scores

The objects created in the above sections and at the beginning of this section include

- lists of training COMPASS and COMPASS-covar objects (CD4Orig, CD4Objs_all_vars_unlog, CD4Objs_all_vars_log, CD4Objs_pca)
- lists of transformed train and test covariate matrices (CD4surfaceDFs.log, CD4surfaceDFs.unlog, CD4surfaceDFs.pca, CD4surfaceDFs.test.log, CD4surfaceDFs.test.unlog, CD4surfaceDFs.test.pca)
- full meta information (CD4meta)

## Full Dataset Results

### Significant Gates

We take the mean gamma estimated for each gate (COMPASS-covariate and COMPASS), then use univariate logistic regressions with hospitalization to determine gates which vary the most between hospitalized and nonhospitalizaed groups.

The orderings appear to be the same across all full runs regardless of covariate transformation or use of covariates.
TODO: some mean gammas differentiate perfectly.

```{r important-gates, options}
# dataframe (unlog covar) of mean gamma and outcome
univar.reg.unlog <- full.Objs[[1]]$fit$mean_gamma %>%
  cbind(full.Objs[[3]]$data$meta %>% 
              select(Cohort) %>%
              mutate(Cohort=(Cohort=="Hospitalized")*1))

# univariate logistic regression
univar.reg.unlog %>%
  select(-Cohort) %>%
  names() %>%
  paste0('Cohort~0+',"`",.,"`")%>%
  map_df(~tidy(glm(as.formula(.x), 
               data= univar.reg.unlog, 
               family="binomial"))) %>%
  arrange(p.value) %>%
  head(15) %>%
  .$term

full.OG$fit$mean_gamma %>%
  cbind(full.OG$data$meta %>% 
              select(Cohort) %>%
              mutate(Cohort=(Cohort=="Hospitalized")*1)) %>%
  select(-Cohort) %>%
  names() %>%
  paste0('Cohort~0+',"`",.,"`")%>%
  map_df(~tidy(glm(as.formula(.x), 
               data= univar.reg.unlog, 
               family="binomial"))) %>%
  arrange(p.value) %>%
  head(15) %>%
  .$term
```

### Comparing to Original COMPASS results

The original COMPASS results appear to match the COMPASS heatmap generated from the github object but is missing a few gates at 40000 iterations. The COMPASS-covariate object, even with 20000 runs, seems to add gates to be considered. In the training data, the resulting PFS scores seem more well-separated using COMPASS-covariate in comparison to original COMPASS.

```{r compare, options}

my_palette <- pal_igv("default", alpha=0.7)(15)

#--------------------------------------------------------
# The paper CD4 run
#--------------------------------------------------------

rownames(CD4$data$meta) <- CD4$data$meta$`SAMPLE ID`
png(file=file.path(parentDirectory,"2-Output/COVID_CD4_paper.png"),
    width=500, height = 750)
plot.COMPASSResult.ComplexHeatmap(CD4,
                                  row_annotation = "Cohort",
                                  row_annotation_colors = list("Non-hospitalized"=my_palette[11],
                                                               "Hospitalized" = my_palette[5]))
dev.off()

#--------------------------------------------------------
# Original COMPASS run
#--------------------------------------------------------


CD4OrigCOMPASS_run <- readRDS("/work/fwh6/COVID/out/40000/orig/CD4/full/orig40000_seed47.rds")

rownames(CD4OrigCOMPASS_run$COMPASSobj$data$meta) <- CD4OrigCOMPASS_run$COMPASSobj$data$meta$`SAMPLE ID`

png(file= paste0(parentDirectory,"2-Output/Original/COVID_CD4_OG_allvar_seed.png"),
      width=500, height = 750)
plot.COMPASSResult.ComplexHeatmap(CD4OrigCOMPASS_run$COMPASSobj, 
                                  row_annotation = "Cohort",
                                  row_annotation_colors = list("Non-hospitalized"=my_palette[11],
                                                               "Hospitalized" = my_palette[5]))

dev.off()

#--------------------------------------------------------
# COMPASS-covariate run
#--------------------------------------------------------

CD4CovarCOMPASS_run <- readRDS("/work/fwh6/COVID/out/40000/covar/pca/log/CD4/full/covar40000_seed47.rds")

# rownames(CD4CovarCOMPASS_run$COMPASScovarobj$data$meta) <- CD4OrigCOMPASS_run$COMPASSobj$data$meta$`SAMPLE ID`
# return as fit-data list
covarTest <- COVtoCOMPASSObj(CD4CovarCOMPASS_run, 
                CD4OrigCOMPASS_run$COMPASSobj,
                CD4surfaceDFs.pca[[1]] %>% as.matrix())
plot.COMPASSCovarResult.ComplexHeatmap(covarTest,
                                       row_annotation = "Cohort",
                                  row_annotation_colors = list("Non-hospitalized"=my_palette[11],
                                                               "Hospitalized" = my_palette[5]))

```

### All-vars vs. PCA

We compare the following performance measures among runs using all-var unlogged covariates, PCA covariates, all-var logged covariates:

- Train and Test ROC (over five folds separately)
- Train boxplots of PFS score
- Convergence statistics like Geweke's


```{r read-in-COMPASSobjs, options}



#--------------------------------------------------------
# Plot heatmaps
#--------------------------------------------------------
my_palette <- pal_igv("default", alpha=0.7)(15)

plotHeatM(full.Objs[[1]],
          paste0(parentDirectory,"2-Output/All-Var-Unlog/COVID_CD4_unlog_allvar_seed.png"),
           "Cohort", list("Hospitalized"=my_palette[11],
                                    "Non-hospitalized"=my_palette[12])) 

plotHeatM(full.Objs[[2]],
          paste0(parentDirectory,"2-Output/All-Var-Log/COVID_CD4_log_allvar_seed.png"),
           "Cohort", list("Hospitalized"=my_palette[11],
                                    "Non-hospitalized"=my_palette[12])) 

plotHeatM(full.Objs[[3]],
          paste0(parentDirectory,"2-Output/PCA/COVID_CD4_pca_seed.png"),
           "Cohort", list("Hospitalized"=my_palette[11],
                                    "Non-hospitalized"=my_palette[12])) 

#--------------------------------------------------------
# Making covar output into COMPASSObj-like list
#--------------------------------------------------------
# origTest <- CD4Orig[[1]]$COMPASSobj
# covarTest <- COVtoCOMPASSObj(CD4Objs_all_vars_log[[1]], CD4Orig[[1]], CD4surfaceMat_log)

#--------------------------------------------------------
# Calculate PFS and add PFS column to meta DF
#--------------------------------------------------------
# PFSDFcovarTest <- getPFSDF(covarTest)
# PFSDForigTest <- getPFSDF(origTest)
# 
# PFSdf <- PFSDFcovarTest %>%
#   bind_rows(PFSDForigTest)

# covarTest$data$meta <- covarTest$data$meta %>%
#   inner_join(PFSDFcovarTest %>% rename("SAMPLE ID"=ID))
# 
# origTest$data$meta <- origTest$data$meta %>%
#   inner_join(PFSDForigTest %>% rename("SAMPLE ID"=ID))

#--------------------------------------------------------
# Paired boxplot for PFS change btwn covar and original
#--------------------------------------------------------

# PFSdf %>%
#   ggplot(aes(x=COMPASS.Type, y=PFS)) + geom_boxplot() +
#   geom_line(aes(group=ID, color=Cohort),alpha=0.5) +facet_wrap(.~Cohort)


# ggsave(filename = file.path(parentDirectory,"2-Output/scaled_CD8COVID_PFS.png"),
#        height = 5, width = 6)

# wilcox.test(PFSdf %>% filter(Cohort=="Hospitalized", COMPASS.Type == "PFSCovar") %>% .$PFS, PFSdf %>% filter(Cohort=="Non-hospitalized", COMPASS.Type == "PFSCovar") %>% .$PFS)
# 
# wilcox.test(PFSdf %>% filter(Cohort=="Hospitalized", COMPASS.Type == "PFSOrig") %>% .$PFS, PFSdf %>% filter(Cohort=="Non-hospitalized", COMPASS.Type == "PFSOrig") %>% .$PFS)

covarObjList <- full.Objs
origObj <- full.OG
covarNames <- c("Unlog", "Log", "PCA")
covarMatList <- full.covMatrices


aggPFS(origObj, covarObjList, covarNames, covarMatList) %>%
  ggplot(aes(x=Type, y=PFS, color=Cohort)) + geom_boxplot()


boxplotPFS(origObj, covarObjList, covarNames, covarMatList)

``` 


```{r orig-plot, options}

# rownames(origTest$data$meta) <- rownames(origTest$fit$mean_gamma)
# #--------------------------------------------------------
# # Plotting using Malisa's complexheatmap function
# #--------------------------------------------------------
# png(file=file.path(parentDirectory,"2-Output/Original/COVID_CD4_orig_seed1.png"),
#     width=500, height = 750)
# origplot <- plot.COMPASSResult.ComplexHeatmap(origTest,
#                                   row_annotation = "Cohort",
#                                   row_annotation_colors = list(
#                                     "Hospitalized"=my_palette[11],
#                                     "Non-hospitalized"=my_palette[12]))
# draw(origplot)
# dev.off()
```

### PFS p-value

```{r pfs-p, options}
pfsDF.log <- aggPFS(origObj, covarObjList, covarNames, covarMatList) %>%
  filter(Type=="Log") %>%
  mutate(Cohort=(Cohort=="Hospitalized")*1)%>%
  left_join(full.Objs[[1]]$data$meta %>% 
              select(-Cohort) %>%
              rename(ID=`SAMPLE ID`))

pfsDF <- aggPFS(origObj, covarObjList, covarNames, covarMatList) %>%
  filter(Type=="Original") %>%
  mutate(Cohort=(Cohort=="Hospitalized")*1)%>%
  left_join(full.Objs[[1]]$data$meta %>% 
              select(-Cohort) %>%
              rename(ID=`SAMPLE ID`))

# regression to model hospitalization
glm(Cohort ~ Age + Sex + PFS, data=pfsDF, family = "binomial")%>%
  tidy()

# wilcoxon comparing PFS for hosp vs. unhosp is different
wilcox.test(pfsDF.log %>% filter(Cohort==1, COMPASS.Type == "PFSCovar") %>% .$PFS, pfsDF.log %>% filter(Cohort==0, COMPASS.Type == "PFSCovar") %>% .$PFS)
wilcox.test(pfsDF %>% filter(Cohort==1, COMPASS.Type == "PFSOrig") %>% .$PFS, pfsDF %>% filter(Cohort==0, COMPASS.Type == "PFSOrig") %>% .$PFS)
```

### Beta Heatmap

We see which covariates are associated with various gates. 

```{r beta-hm, options}
# mean_beta <- rowMeans(covarTest$fit$beta, dim=2)
# 
# Heatmap(mean_beta, cluster_rows = FALSE,
#                           show_row_dend = FALSE,
#                           cluster_columns = FALSE, cluster_column_slices = FALSE)


```


## Regression Comparisons

### Convergence

We compare the acceptance rates of COMPASS vs. COMPASS-covariate. We plot the Geweke's, Raftery and Lewis, and Heidelberg and Welch statistic for the two gates' patients' gamma values.

```{r convergence, options}
# cbind(x=origTest$fit$A_gamma, y=covarTest$fit$A_gamma) %>%
#   as.data.frame() %>%
#   ggplot(aes(x=x,y=y)) +
#   geom_point() +
#   geom_abline() +
#   xlab("Original COMPASS Acceptance Rate") +
#   ylab("COMPASS-covar Acceptance Rate") +
#   ggtitle("Gamma Acceptance Rates")
```

### LASSO

We take the raw count matrices and calculate the log fold change for each gate for each patient. We then apply LASSO to these quantities in a regression.

First, we calculate the log-fold change for each gate and individual, for each of the train datasets of interest. 
TODO: LASSO doesn't like the lambda we give it sometimes (glmnet suggests not using a single lambda value). There are additionally 0's in the count matrices. I'm currently adding 1 to the denominator. Also, need to correct to be percentages not counts.

```{r log-fold-change, options}
NS.percent.full <- t(apply(CD4ns_final %>% as.matrix(), 1, function(row) row / sum(row) * 100))
NU.percent.full <- t(apply(CD4nu_final %>% as.matrix(), 1, function(row) row / sum(row) * 100))
LASSORegResults <- do.call(rbind,lapply(1:5, function(x) fold_resultGates(x, CD4Parts, CD4meta, NS.percent.full,
                                                                    NU.percent.full, 
                                                                    numCyt=7, ID="SAMPLE ID"))) 

kable(LASSORegResults) %>%
  kable_classic_2()

#avgRegVals(PIRegResults, "PI")
  
```


### Polyfunctional Index

We use a polyfunctional index calculated from the frequency of cells performing $i$ functions. We first sum up the stimulated count matrix columns to aggregate cells by number of functions they perform, then calculate the percentage.

Once we have the percentage matrix, we feed it into the Polyfunctionality index formula.

We then aggregate these PI scores to meta information and run a regression.


We then get the ROC associated with the PI for the test and train data.

```{r pi-roc, options}
numCyt <- 7
PI.scores <- lapply(1:5, function(i) meta.orig[[i]] %>%
                      cbind(PIScore=apply(Percent.Matrix(NS.orig[[i]], numCyt), 1, function(row) PI.Score(row, numCyt, 5))))

PIRegResults <- do.call(rbind,lapply(1:5, function(x) fold_resultPI(x, CD4Parts, CD4meta, CD4ns_final,
                                                                    CD4surfaceDFs.log[[x]], CD4surfaceDFs.test.log[[x]],
                                                                    numCyt, q=1, ID="SAMPLE ID"))) 

kable(PIRegResults) %>%
  kable_classic_2()

avgRegVals(PIRegResults, "PI")
```

```{r reg-PI, options}
PI.scores[[1]] %>%
  ggplot(aes(x=Cohort, y=PIScore)) + geom_boxplot()

# regPI <- glm(Cohort ~ . -Cohort -`SAMPLE ID` , family = "binomial",
#     data=PI.scores[[5]] %>% mutate(Cohort=(Cohort=="Hospitalized")*1) %>%
#       select(`SAMPLE ID`, Cohort, PIScore) %>%
#       left_join(CD4surfaceDFs.log[[5]] %>% rownames_to_column(var="SAMPLE ID")))
# 
# 
# summary(regPI)

wilcox.test(PI.scores[[1]] %>% filter(Cohort=="Hospitalized") %>% .$PIScore, pfsDF.log %>% filter(Cohort=="Non-hospitalized") %>% .$PIScore)
```

### PFS Regression

#### Using Mean Gamma estimated from Covariates

We use a regression to predict the status (hospitalized vs. non-hospitalized) based on the PFS of a patient.

To test each fold's ability to estimate PFS/FS for each test patient, we 
1. We pull beta samples from the train beta posterior for each of the test samples. 
2. We predict gamma by multiplying Luminex level by the beta sample coefficient (and adding beta sample intercept), then taking inverse logit.
2. We use gamma to calculate estimated PFS and FS for test.


We sample entire beta matrices and calculate the mean beta matrix. We then multiply by the covariate test matrix and inverse-logit to get the mean gamma matrix for the test patients. The mean gamma matrix is used to find the estimated PFS for each patient.
We train regressions on the original and covariate datasets.

Since we have around 10 hospitalized and 20 hospitalized patients in each training set, we stick to only including PFS in a logistic regression with infection. The train-test regression results are below for all-vars logged, all-vars unlogged, and PCA respectively. PCA appears to have the best test AUC.

```{r test-reg, options}


logRegResults <- do.call(rbind,lapply(1:5, function(x) fold_result(x, CD4Parts, CD4Orig, CD4Objs_all_vars_log,                                               CD4surfaceDFs.log, CD4surfaceDFs.test.log,
            rep(list(CD4meta),5)))) 

avgRegVals(logRegResults, "Logged All-Var")

kable(logRegResults) %>%
  kable_classic_2()

unlogRegResults <- do.call(rbind,lapply(1:5, function(x) fold_result(x, CD4Parts, CD4Orig, CD4Objs_all_vars_unlog,                                                   CD4surfaceDFs.unlog, CD4surfaceDFs.test.unlog,
            rep(list(CD4meta),5))))

avgRegVals(unlogRegResults, "Unlogged All-Var")

kable(unlogRegResults) %>%
  kable_classic_2()


PCARegResults <- do.call(rbind,lapply(1:5, function(x) fold_result(x, CD4Parts, CD4Orig, CD4Objs_pca,
                                      CD4surfaceDFs.pca, CD4surfaceDFs.test.pca,
            rep(list(CD4meta),5))))

avgRegVals(PCARegResults, "Logged PCA")

kable(PCARegResults) %>%
  kable_classic_2()
```


#### Running COMPASS-covar on the test flow data

In the above regression, we are not incorporating test flow data at all; this makes for an unfair comparison with the PI and LASSO methods. We now try to run COMPASS-covar on the test data to get the PFS, and use the beta coefficients relating PFS  to hospitalization learned from the training data.

```{r test-COMPASS-covar, options}
# categories
CAT <- rep(list(getCats(CD4ns_final)), 15)

# Ns and Nu for each simulation
NS.test <- c(foldedNs(type="test", 1, 3), foldedNs(type="test", 2, 3), foldedNs(type="test", 3, 3), foldedNs(type="test", 4,3 ), foldedNs(type="test", 5,3))
NU.test <- c(foldedNu(type="test", 1,3), foldedNu(type="test", 2,3), foldedNu(type="test", 3,3), foldedNu(type="test", 4,3), foldedNu(type="test", 5,3))

# seeds for each simulation
seeds <- c(rep(1,3), rep(2,3), rep(3,3), rep(4,3), rep(5,3))

# covariate matrix for each simulation
covMatrices.test <- do.call(c, 
        lapply(1:5,
               function(i) list(CD4surfaceDFs.test.unlog[[i]], CD4surfaceDFs.test.log[[i]], CD4surfaceDFs.test.pca[[i]]))) 

# save paths for each simulation
covpaths.test <- rep(c("all_vars/unlog/CD4/test", "all_vars/log/CD4/test", "pca/log/CD4/test"),5)
```


```{r compass-covariate-run, options}



# cl <- makeCluster(15) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:15, .packages = c("dplyr", "COMPASS")) %dopar% {
# 
# 
#   COMPASS_covar(NS.test[[i]],
#                 NU.test[[i]], covMatrices.test[[i]] %>% as.matrix(),
#                 CAT[[i]],
#                 iter=40000, seed=seeds[i],
#                 paste0("/work/fwh6/COVID/out/40000/covar/",covpaths.test[i]),
#                 "covarTest")
# }
# 
# stopCluster(cl) # stop the cluster

```


We do the same with COMPASS.

```{r compass-orig-setup-test, options}
NS.orig <- c(foldedNs(type="test", 1, 1), foldedNs(type="test", 2, 1), foldedNs(type="test", 3, 1), foldedNs(type="test", 4,1), foldedNs(type="test", 5,1))
NU.orig <- c(foldedNu(type="test", 1,1), foldedNu(type="test", 2,1), foldedNu(type="test", 3,1), foldedNu(type="test", 4,1), foldedNu(type="test", 5,1))
meta.orig <-c(foldedMeta(type="test", 1,1), foldedMeta(type="test", 2,1), foldedMeta(type="test", 3,1), foldedMeta(type="test", 4,1), foldedMeta(type="test", 5,1))
seeds.orig <- c(rep(1,1), rep(2,1), rep(3,1), rep(4,1), rep(5,1))
origpaths <- rep(c("CD4/test/"), 5)
```

```{r compass-orig, options}

# cl <- makeCluster(5) # create a cluster with 5 workers
# registerDoParallel(cl) # register the cluster for parallel computation
# 
# results <- foreach(i = 1:5, .packages = c("dplyr", "COMPASS")) %dopar% {
# 
# COMPASS_orig(NS.orig[[i]], NU.orig[[i]], "SAMPLE ID",
#              meta.orig[[i]], 40000, seeds.orig[[i]],
#              paste0("/work/fwh6/COVID/out/40000/orig/",origpaths[i]), "origTest")
# 
# }
# 
# stopCluster(cl) # stop the cluster
```

```{r read-in-test, options}
CD4Objs_all_vars_log.test <- readInObjs("/work/fwh6/COVID/out/40000/covar/all_vars/log/CD4/test/",
                      pattern="covarTest40000_seed.*")

CD4Objs_all_vars_unlog.test <- readInObjs("/work/fwh6/COVID/out/40000/covar/all_vars/unlog/CD4/test/",
                      pattern="covarTest40000_seed.*")

CD4Objs_pca.test <- readInObjs("/work/fwh6/COVID/out/40000/covar/pca/log/CD4/test/",
                      pattern="covarTest40000_seed.*")

CD4Orig.test <- readInObjs("/work/fwh6/COVID/out/40000/orig/CD4/test/",
                      pattern="origTest40000_seed.*")
```

Once we have the test COMPASS-covar objects, we calculate the PFS.

```{r regression, options}
testFlowOGROC <- function(foldNum) {
testObj <- CD4Orig.test[[foldNum]]$COMPASSobj
trainObj <- CD4Orig[[foldNum]]$COMPASSobj

  testDat <- getPFSDF(testObj) %>% mutate(Cohort_Bin=(Cohort=="Hospitalized")*1)
  trainDat <- getPFSDF(trainObj) %>% mutate(Cohort_Bin=(Cohort=="Hospitalized")*1)
  
  trainMod1 <- glm(Cohort_Bin ~ PFS, data=trainDat, family = "binomial")
  
  Preds <- predict(trainMod1, newdata=testDat, type = "response")
  PredsTrain <- predict(trainMod1, type="response")
  
  trainROC<-getROCs(CD4Parts[[foldNum]], CD4meta, PredsTrain)$auc
  testROC <-getROCs(setdiff(1:nrow(CD4meta),CD4Parts[[foldNum]]), CD4meta, Preds)$auc
  
  return(data.frame(i=foldNum, 
                    testROC = testROC,
                    trainROC=trainROC))

}


testFlowROC <- function(foldNum) {
  testOGObj <- CD4Orig.test[[foldNum]]$COMPASSobj
  testObj <- COVtoCOMPASSObj(CD4Objs_all_vars_log.test[[foldNum]], testOGObj, CD4surfaceDFs.test.log[[foldNum]])  
  
  trainObj <- COVtoCOMPASSObj(CD4Objs_all_vars_log[[foldNum]], CD4Orig[[foldNum]]$COMPASSobj, CD4surfaceDFs.log[[foldNum]])
  testDat <- getPFSDF(testObj) %>% mutate(Cohort_Bin=(Cohort=="Hospitalized")*1)
  
  trainMod1 <- getTrainReg(CD4Parts, foldNum, CD4meta, CD4surfaceDF.full.log, trainObj, "SAMPLE ID")
  
  Preds <- predict(trainMod1, newdata=testDat, type = "response")
  PredsTrain <- predict(trainMod1, type="response")
  
  trainROC<-getROCs(CD4Parts[[foldNum]], CD4meta, PredsTrain)$auc
  testROC <-getROCs(setdiff(1:nrow(CD4meta),CD4Parts[[foldNum]]), CD4meta, Preds)$auc
  
  return(data.frame(i=foldNum, 
                    testROC = testROC,
                    trainROC=trainROC))

}

logRegResults <- do.call(rbind,lapply(1:5, function(x) testFlowROC(x))) 

logRegResults %>% kable() %>%
  kable_classic_2()

OGRegResults <- do.call(rbind,lapply(1:5, function(x) testFlowOGROC(x))) 

OGRegResults %>% kable() %>%
  kable_classic_2()

```
